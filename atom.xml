<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eson Wong&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bb64ee8880e0f75605904ab137b75e19</icon>
  <subtitle>编程笔记，投资记录, 读书总结, 生活心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.esonwong.com/"/>
  <updated>2021-03-27T15:48:26.112Z</updated>
  <id>https://blog.esonwong.com/</id>
  
  <author>
    <name>Eson Wong</name>
    <email>itiwll@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 中创建对象的设计模式</title>
    <link href="https://blog.esonwong.com/javascript-create-object/"/>
    <id>https://blog.esonwong.com/javascript-create-object/</id>
    <published>2020-08-05T23:16:09.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/object.png" alt="object"></p><h2 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1. 字面量"></a>1. 字面量</h2><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat1 = &#123;</span><br><span class="line">name: <span class="string">"cat1"</span>,</span><br><span class="line">  type: <span class="string">"cat"</span>,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat2 = &#123;</span><br><span class="line">  name: <span class="string">"cat2"</span>,</span><br><span class="line">  type: <span class="string">"cat"</span>,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 JavaScript 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>不能产生可服用的对象</li></ul><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> object = &#123;</span><br><span class="line"> name: name,</span><br><span class="line">   type: <span class="string">"cat"</span>,</span><br><span class="line"> run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat1 = createCat(<span class="string">"cat1"</span>);</span><br><span class="line"><span class="keyword">const</span> cat2 = createCat(<span class="string">"cat2"</span>);</span><br></pre></td></tr></table></figure><p>工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><a id="more"></a><h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>无法识别实力的对象类型</li></ul><h2 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3.构造函数模式"></a>3.构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.type = <span class="string">"cat"</span>;</span><br><span class="line"><span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"cat1"</span>);</span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"cat2"</span>);</span><br></pre></td></tr></table></figure><p>JavaScript 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。<br>执行构造函数 <code>new Cat()</code>:</p><ol><li>首先会创建一个新对象</li><li>然后将新对象的原型<code>__proto__</code>指向构造函数的 prototype 属性</li><li>然后将执行上下文中的 this 指向这个新对象</li><li>最后再执行整个函数，如果返回值不是对象，则返回新建的对象。</li></ol><p>因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>实例的函数属性<code>run</code>会重复创建，<code>run</code>是可以通用的，浪费了不必要的内存空间</li></ul><h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Cat.prototype.type = <span class="string">"cat"</span>;</span><br><span class="line">Cat.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.colors = [<span class="string">"orange"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">cat1.colors[<span class="number">0</span>] = <span class="string">"black"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cat2.colors); <span class="comment">// ["black"]</span></span><br></pre></td></tr></table></figure><p>因为每一个函数都有一个<code>prototype</code>属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>通过<code>prototype</code>对象共用属性和方法</li></ul><h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>无法传递初始化参数</li><li>共用的引用类型的属性的修改会影响所有实例</li></ul><h2 id="5-组合使用构造函数模式和原型模式"><a href="#5-组合使用构造函数模式和原型模式" class="headerlink" title="5. 组合使用构造函数模式和原型模式"></a>5. 组合使用构造函数模式和原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.type = <span class="string">"cat"</span>;</span><br><span class="line">  <span class="keyword">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"cat1"</span>);</span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"cat2"</span>);</span><br></pre></td></tr></table></figure><p>这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用了两种不同的模式，所以对于代码的封装性不够好。</li></ul><h2 id="6-动态原型模式"><a href="#6-动态原型模式" class="headerlink" title="6. 动态原型模式"></a>6. 动态原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.type = <span class="string">"cat"</span>;</span><br><span class="line">  <span class="keyword">this</span>.colors = [];</span><br><span class="line"><span class="keyword">if</span>(type <span class="keyword">of</span> <span class="keyword">this</span>.run !== <span class="string">'function'</span>)&#123;</span><br><span class="line">  Cat.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"小猫快跑"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>封装了原型</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/object.png&quot; alt=&quot;object&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-字面量&quot;&gt;&lt;a href=&quot;#1-字面量&quot; class=&quot;headerlink&quot; title=&quot;1. 字面量&quot;&gt;&lt;/a&gt;1. 字面量&lt;/h2&gt;&lt;p&gt;我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cat1 = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	name: &lt;span class=&quot;string&quot;&gt;&quot;cat1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: &lt;span class=&quot;string&quot;&gt;&quot;cat&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	run: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;小猫快跑&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cat2 = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&quot;cat2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: &lt;span class=&quot;string&quot;&gt;&quot;cat&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	run: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;小猫快跑&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但 JavaScript 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象。&lt;/p&gt;
&lt;h3 id=&quot;缺陷&quot;&gt;&lt;a href=&quot;#缺陷&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能产生可服用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-工厂模式&quot;&gt;&lt;a href=&quot;#2-工厂模式&quot; class=&quot;headerlink&quot; title=&quot;2. 工厂模式&quot;&gt;&lt;/a&gt;2. 工厂模式&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createCat&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 name: name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type: &lt;span class=&quot;string&quot;&gt;&quot;cat&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 run: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;小猫快跑&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cat1 = createCat(&lt;span class=&quot;string&quot;&gt;&quot;cat1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cat2 = createCat(&lt;span class=&quot;string&quot;&gt;&quot;cat2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="class" scheme="https://blog.esonwong.com/tags/class/"/>
    
      <category term="Web 开发" scheme="https://blog.esonwong.com/tags/Web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术" scheme="https://blog.esonwong.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Javascript" scheme="https://blog.esonwong.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="https://blog.esonwong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面向对象" scheme="https://blog.esonwong.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Babel 的 Class 的转换</title>
    <link href="https://blog.esonwong.com/Babel-%E7%9A%84-Class-%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://blog.esonwong.com/Babel-%E7%9A%84-Class-%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-07-01T22:15:45.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/babel.png" alt="babel class 转换"></p><p>ES6 加入了 Class 的语法，Class 的大部分功能 ES5 都可以做到，我们可以把 <code>class</code> 看作是一个语法糖。本篇文章我们一步步来看看 Babel 是怎么把 <code>class</code> 转换成 ES5 语法的。</p><a id="more"></a><h2 id="观察方发"><a href="#观察方发" class="headerlink" title="观察方发"></a>观察方发</h2><p>在 Babel 的官网上有一个 <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Try it out</a> 的网页可以方便的看到编译后的代码。我们要看转换成 ES5 的语法，我们在 ENV PRESET 取消勾选 Enabled.</p><h2 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h2><p>我们先来看看一个没有属性、方法和构造函数的类会被转换成什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------ 转换 ------------------ //</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, A);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure><p>可以看到 <code>class A{}</code> 被转化成了一个函数 <code>A</code>。除此之外还生成了一个函数 <code>_classCallCheck</code> 检测 <code>A</code> 是否用 <code>new</code> 关键只来调用的。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>我们来添加一个 <code>constructor</code> 方法到 <code>class A{}</code> 里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.propA = <span class="string">"A"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------ 转换 ------------------ //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 略：function _classCallCheck()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, A);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.propA = <span class="string">"A"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转换后 <code>constructor</code> 方法内的代码内容被简单的搬到 <code>function A(){}</code> 内部。 </p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>类的公有属性声明仍然处于实验性功能第3阶段。开启此特性我们要在 PULGINS 里添加 <code>@babel/plugin-proposal-class-properties</code> 插件。<br>添加一个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.propA = <span class="string">"A"</span></span><br><span class="line">  &#125;</span><br><span class="line">  propB = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------ 转换 ------------------ //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 略：function _classCallCheck()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, A);</span><br><span class="line">  <span class="keyword">this</span>.propB = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.propA = <span class="string">"A"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>公有属性 <code>propB</code> 转换成 <code>fuxntion A(){}</code> 函数内的的 <code>this.propB</code>。</p><blockquote><p>私有属性同样还没通过标准，需要添加 <code>@babel/plugin-proposal-class-properties</code> 插件来转换。</p></blockquote><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>添加一个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  method()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"method"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------ 转换 ------------------ //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 略：function _classCallCheck()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123; </span><br><span class="line">    <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>; descriptor.configurable = <span class="literal">true</span>; <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>; <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps); </span><br><span class="line">  <span class="keyword">return</span> Constructor; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, A);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(A, <span class="literal">null</span>, [&#123;</span><br><span class="line">    key: <span class="string">"method"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">staticMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>Bable 使用闭包函数并创建了一个 <code>_createClass</code> 函数来给 <code>function A(){}</code> 添加方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel: Try it out</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类 - JavaScript | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/babel.png&quot; alt=&quot;babel class 转换&quot;&gt;&lt;/p&gt;
&lt;p&gt;ES6 加入了 Class 的语法，Class 的大部分功能 ES5 都可以做到，我们可以把 &lt;code&gt;class&lt;/code&gt; 看作是一个语法糖。本篇文章我们一步步来看看 Babel 是怎么把 &lt;code&gt;class&lt;/code&gt; 转换成 ES5 语法的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="babel" scheme="https://blog.esonwong.com/tags/babel/"/>
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="class" scheme="https://blog.esonwong.com/tags/class/"/>
    
      <category term="Web 开发" scheme="https://blog.esonwong.com/tags/Web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术" scheme="https://blog.esonwong.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Javascript" scheme="https://blog.esonwong.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>网络遥控车互联网控制教程</title>
    <link href="https://blog.esonwong.com/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.esonwong.com/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-15T09:59:56.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/4g%E7%BD%91%E7%BB%9C%20RC%20%E9%81%A5%E6%8E%A7%E8%BD%A603%20-%20%E6%97%A0%E9%99%90%E8%B7%9D%E7%A6%BB%E8%BF%9C%E7%A8%8B%E9%81%A5%E6%8E%A7%EF%BC%9F-%20%E5%B0%81%E9%9D%A2.jpg" alt="4G 网络 RC 遥控车03 - 无限距离远程遥控？"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上篇[WiFi/4G/5G 网络遥控车制作教程]介绍了在局域网下控制遥控车，要实现远程控制，必须让遥控车在互联网上可以访问遥控车。</p><p>本教程教大家如何让遥控小车接入移动互联网实现 4G/5G 网络无限距离遥控。</p><a id="more"></a><h2 id="4G-5G-网络连接"><a href="#4G-5G-网络连接" class="headerlink" title="4G/5G 网络连接"></a>4G/5G 网络连接</h2><p>为了让网络遥控车接入互联网，按[WiFi/4G/5G 网络遥控车制作教程]做好遥控车之后，要让小车上的树莓派连接到 4G/5G 网络。</p><h3 id="UBS-4G-5G-网卡"><a href="#UBS-4G-5G-网卡" class="headerlink" title="UBS 4G/5G 网卡"></a>UBS 4G/5G 网卡</h3><p>USB 4G/5G 网卡是现在最方便的选择。我使用的是华为的 E8372h。插上树莓派就能联网</p><h3 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h3><p>你也可以用 4G/5G 手机（或者 4G/5G 路由器）来连接互联网。<br>开启手机 Wi-Fi 热点:<br><img src="../asset/wifi%E7%83%AD%E7%82%B9.png" alt="WiFi 热点"></p><p>把手机安装到车上，树莓派上连接手机 Wi-Fi 热点。</p><blockquote><p>树莓派连接 Wi-Fi 的方法请自行搜索。</p></blockquote><p>此时树莓派是没有公网的 ip 地址的，还不能通过互联网连接到遥控车。</p><h2 id="外网访问-网络穿透"><a href="#外网访问-网络穿透" class="headerlink" title="外网访问 - 网络穿透"></a>外网访问 - 网络穿透</h2><p>我们通过使用 frp 网络穿透软件实现互联网对遥控车的访问。 network-rc 于 v0.5.0 版本里内置了 frp 客户端和作者提供的 frp 服务的配置。</p><p>使用下面的命令运行即可开启网络穿透功能(不需要<code>{}</code>)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./network-rc/node ./network-rc/index.js -f -o 9011 --tsl -p &#123;你想设置的控制界面登陆密码&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于可通过互联网访问，务必设置连接密码。作者提供的 frp 服务器可用端口为 9002 ～ 9060</p></blockquote><p>网络穿透成功后即可通过 <a href="http://home.esonwong.com:9011" target="_blank" rel="noopener">http://home.esonwong.com:9011</a> (9011 替换成你设置的端口号) 访问你的遥控车控制界面。</p><p>作者提供的免费的 frp 服务器(v0.9.11 已恢复)，是运行在自家用的路由器上的，广东电信的网络。如果各位小伙伴离湖北比较远或者 4G/5G 核心、控制端的网络和 frp 穿透服务器属于不通的运营商会增加视频传输延迟。</p><blockquote><p>受电信运营商的影响，作者提供的 frp 服务不是特别问题。</p></blockquote><h3 id="免费-frp-网络穿透服务器"><a href="#免费-frp-网络穿透服务器" class="headerlink" title="免费 frp 网络穿透服务器"></a>免费 frp 网络穿透服务器</h3><p>搜索引擎搜索“免费的 frp”，可以找到好心的网友提供的免费的 frp 服务器。</p><p>需要找到以下服务器的配置：</p><ul><li>服务器地址 <code>server_addr</code></li><li>服务器端口 <code>server_port</code></li><li>服务 token <code>token</code></li><li>用户名 user</li></ul><p>使用其它穿透服务器的命令(不需要<code>{}</code>)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo node index.js -f -o &#123;访问端口&#125; -p &#123;你想设置的控制界面登陆密码&#125; --frpServer &#123;服务器地址&#125; --frpServerPort &#123;服务器端口&#125; -frpServerToken &#123;frp 的 token&#125; --frpServerUser &#123;frp 的用户名&#125;</span><br></pre></td></tr></table></figure><h2 id="开机启动-network-rc"><a href="#开机启动-network-rc" class="headerlink" title="开机启动 network-rc"></a>开机启动 network-rc</h2><p>为了方便接上电源即可控制遥控车，我们将 network-rc 设置为开机启动。</p><p>增加 network-rc 服务，在 <code>/etc/systemd/system/</code> 目录下新建 <code>network-rc.service</code> 文件，替换下方文本里的 network-rc 路径和密码(不需要<code>{}</code>）保存到文件里。</p><blockquote><p>创建和编辑 <code>/etc/systemd/system/network-rc.service</code> 文件需要 root 。如果用图形界面使用 <code>sudo pcmanfm</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;network-rc</span><br><span class="line">After&#x3D;syslog.target  network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;root</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#123;network-rc文件夹路径&#125;&#x2F;node &#123;network-rc文件夹路径&#125;&#x2F;index.js -f -o &#123;访问端口&#125; -p &#123;你想设置的控制界面登陆密码&#125; --tsl</span><br><span class="line"># 比如 ExecStart&#x3D;&#x2F;home&#x2F;pi&#x2F;network-rc&#x2F;node &#x2F;home&#x2F;pi&#x2F;network-rc&#x2F;index.js -f -o 9011 -p password --tsl</span><br><span class="line">Restart&#x3D; always</span><br><span class="line">RestartSec&#x3D;1min</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> network-rc.service</span><br></pre></td></tr></table></figure><p>network-rc 将在树莓派开机时和网络切换时自动运行。</p><p>查看服务状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status network-rc.service</span><br></pre></td></tr></table></figure><p>如果更新了文件需要运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload network-rc.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> network-rc.service</span><br><span class="line">sudo systemctl start network-rc.service</span><br></pre></td></tr></table></figure><h2 id="4G-网络下延迟测试"><a href="#4G-网络下延迟测试" class="headerlink" title="4G 网络下延迟测试"></a>4G 网络下延迟测试</h2><iframe src="//player.bilibili.com/player.html?aid=498078613&bvid=BV15K411W7bK&cid=188867916&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="480px"></iframe><p>链接：<a href="https://www.bilibili.com/video/BV15K411W7bK" target="_blank" rel="noopener">树莓派 4G 网络遥控车图传延迟测试</a></p><h2 id="4G-网络下的实际遥控效果"><a href="#4G-网络下的实际遥控效果" class="headerlink" title="4G 网络下的实际遥控效果"></a>4G 网络下的实际遥控效果</h2><iframe src="//player.bilibili.com/player.html?aid=968342042&bvid=BV14p4y1X7qf&cid=195694954&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="480px"></iframe><h2 id="交流微信群"><a href="#交流微信群" class="headerlink" title="交流微信群"></a>交流微信群</h2><p>入群方法添: 加微信 EsonWong_ 备注 Network RC</p><h2 id="捐赠"><a href="#捐赠" class="headerlink" title="捐赠"></a>捐赠</h2><p><img src="../asset/wechat-donate.jpg" alt="微信赞赏吗"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li><li><a href="https://github.com/itiwll/network-rc" target="_blank" rel="noopener">network-rc</a></li><li>[WiFi/4G/5G 网络遥控车制作教程]</li><li>[4G 5G 网络 RC 遥控车 03 - 无限距离远程遥控？]</li><li><a href="https://www.bilibili.com/video/BV15K411W7bK" target="_blank" rel="noopener">树莓派 4G 网络遥控车图传延迟测试</a></li><li><a href="https://www.bilibili.com/video/BV1fi4y1t7dx/" target="_blank" rel="noopener">4G/5G 网络 RC 遥控车 04 - 人工智能(zhang)，自动驾驶，人体跟随</a>]</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/4g%E7%BD%91%E7%BB%9C%20RC%20%E9%81%A5%E6%8E%A7%E8%BD%A603%20-%20%E6%97%A0%E9%99%90%E8%B7%9D%E7%A6%BB%E8%BF%9C%E7%A8%8B%E9%81%A5%E6%8E%A7%EF%BC%9F-%20%E5%B0%81%E9%9D%A2.jpg&quot; alt=&quot;4G 网络 RC 遥控车03 - 无限距离远程遥控？&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;上篇[WiFi/4G/5G 网络遥控车制作教程]介绍了在局域网下控制遥控车，要实现远程控制，必须让遥控车在互联网上可以访问遥控车。&lt;/p&gt;
&lt;p&gt;本教程教大家如何让遥控小车接入移动互联网实现 4G/5G 网络无限距离遥控。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教程" scheme="https://blog.esonwong.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="网络遥控车" scheme="https://blog.esonwong.com/categories/%E6%95%99%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术" scheme="https://blog.esonwong.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络遥控车" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
      <category term="网络 RC" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C-RC/"/>
    
      <category term="WiFi/4G/5G 网络遥控车" scheme="https://blog.esonwong.com/tags/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
      <category term="树莓派" scheme="https://blog.esonwong.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="网络图传" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%BC%A0/"/>
    
      <category term="树莓派小车" scheme="https://blog.esonwong.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%BD%A6/"/>
    
      <category term="WiFi/4G/5G 网络遥控车制作教程" scheme="https://blog.esonwong.com/tags/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
    
      <category term="无限距离" scheme="https://blog.esonwong.com/tags/%E6%97%A0%E9%99%90%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>WiFi/4G/5G 网络遥控车制作教程</title>
    <link href="https://blog.esonwong.com/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.esonwong.com/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-09T10:26:19.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/4g%E7%BD%91%E7%BB%9Crc%E9%81%A5%E6%8E%A7%E8%BD%A602-%E5%BC%80%E7%AF%87-%E5%B0%81%E9%9D%A2.jpg" alt="WiFi/4G/5G 网络遥控车制作教程"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本教程介绍使用树莓派和遥控车制作一台可以通过网络控制的遥控车。软件使用我开发的 <a href="https://github.com/itiwll/network-rc" target="_blank" rel="noopener">network-rc</a>。</p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul><li>树莓派 3B+ (300 元)</li><li>树莓派摄像头 (15 元) / ps3 摄像头 (40 远)</li><li>移动电源 (60 元) / USB 输出降压模块 (?元)</li><li>环奇 743A (286 元，某宝上找不到了)</li><li>杜邦线(公对公 x1, 公对母 x4) (3 元)</li><li>其它固定材料</li></ul><a id="more"></a><h2 id="树莓派软件安装运行"><a href="#树莓派软件安装运行" class="headerlink" title="树莓派软件安装运行"></a>树莓派软件安装运行</h2><h3 id="安装-network-rc"><a href="#安装-network-rc" class="headerlink" title="安装 network-rc"></a>安装 network-rc</h3><ol start="0"><li>树莓派安装 buster 版本以上系统连接摄像头，连接 wifi。</li></ol><blockquote><p><strong>注意：在最新树莓派系统上存在兼通性问题， 使用此版本系统<a href="http://downloads.raspberrypi.org/raspbian/images/raspbian-2020-02-07/" target="_blank" rel="noopener">http://downloads.raspberrypi.org/raspbian/images/raspbian-2020-02-07/</a></strong></p></blockquote><blockquote><p>网络上有很多树莓派系统安装教程，请自行搜索.</p></blockquote><ol><li>在树莓派上下载 <a href="https://github.com/itiwll/network-rc" target="_blank" rel="noopener">network-rc</a> 软件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://network-rc.esonwong.com/download/network-rc.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备用地址下载</span></span><br><span class="line">wget https://esonwong.synology.me:5011/download/network-rc.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf network-rc.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>运行程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./network-rc/node ./network-rc/index.js</span><br></pre></td></tr></table></figure><ol start="4"><li>用同一局域网网下的浏览器里打开 <code>http://树莓派的ip地址:8080</code> 即可看到控制界面</li></ol><h2 id="环奇-743A-改装"><a href="#环奇-743A-改装" class="headerlink" title="环奇 743A 改装"></a>环奇 743A 改装</h2><p>如果你是用其它车的话，只要舵机和电调的接线和控制信号通用即可(<strong>仅支持三线的电调和舵机</strong>)。</p><p><img src="../asset/%E6%A0%91%E8%8E%93%E6%B4%BE-GPIO-%E8%BF%9E%E6%8E%A5%E5%B0%8F%E8%BD%A6.jpg" alt="树莓派 GPIO 连接小车"></p><h3 id="1-取下舵机和电调与接收机之间的连线"><a href="#1-取下舵机和电调与接收机之间的连线" class="headerlink" title="1. 取下舵机和电调与接收机之间的连线"></a>1. 取下舵机和电调与接收机之间的连线</h3><h3 id="2-连接到树莓派"><a href="#2-连接到树莓派" class="headerlink" title="2. 连接到树莓派"></a>2. 连接到树莓派</h3><p>树莓派关机。</p><ul><li>将舵机和电调的正极线(VCC\红色) 和 电调的正极线用公对公杜邦线连接起来，舵机从电调上取电。</li><li>使用公对母杜邦线将舵机的信号线(PWM\白色或黄色) 连接到树莓派的 GPIO 12 (编号 32\PWM0)</li><li>使用公对母杜邦线将电调的信号线(PWM\白色或黄色) 连接到树莓派的 GPIO 13 (编号 33\PWM1)</li><li>使用公对母杜邦线将舵机和电调的地线(Ground\黑色或棕色) 连接到树莓派的 GPIO Group，建议连接到编号 30 和 34，方便理线。</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>树莓派接通电源，开机，运行软件。小车接通电源，开机。打开浏览器，开始享用吧。</p><h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><iframe src="//player.bilibili.com/player.html?aid=882676306&bvid=BV1iK4y1r7mD&cid=177948237&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="480px"> </iframe><p>链接：<a href="../asset/4g网络rc遥控车02-开篇-封面.jpg">WiFi/4G/5G 网络遥控车制作教程</a></p><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h2><p>作为一个可以网络控制且拥有网络图传的小车，它的梦想是自己周游世界（没有熊孩子的世界）。下次我会教大家如何通过 4G 网络来控制小车。</p><p><a href="../网络遥控车互联网控制教程/">网络遥控车互联网控制教程</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://space.bilibili.com/96740361" target="_blank" rel="noopener">Bilibili EsonWong</a></li><li><a href="https://github.com/itiwll/network-rc" target="_blank" rel="noopener">network-rc</a></li><li><a href="../asset/4g网络rc遥控车02-开篇-封面.jpg">WiFi/4G/5G 网络遥控车制作教程</a></li><li>[4G 5G 网络 RC 遥控车 03 - 无限距离远程遥控？]</li><li><a href="https://www.bilibili.com/video/BV15K411W7bK" target="_blank" rel="noopener">树莓派 4G 网络遥控车图传延迟测试</a></li><li><a href="https://www.bilibili.com/video/BV1fi4y1t7dx/" target="_blank" rel="noopener">4G/5G 网络 RC 遥控车 04 - 人工智能(zhang)，自动驾驶，人体跟随</a></li><li><a href="https://www.bilibili.com/video/BV14C4y1p7ap/" target="_blank" rel="noopener">4G/5G 网络 RC 遥控车 - 05 摄像头！麦克风！云台！语音对讲！</a></li><li><a href="../网络遥控车互联网控制教程/">网络遥控车互联网控制教程</a></li></ul><h2 id="交流微信群"><a href="#交流微信群" class="headerlink" title="交流微信群"></a>交流微信群</h2><p>入群方法添: 加微信 EsonWong_ 备注 Network RC</p><h2 id="捐赠"><a href="#捐赠" class="headerlink" title="捐赠"></a>捐赠</h2><p><img src="../asset/wechat-donate.jpg" alt="微信赞赏吗"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/4g%E7%BD%91%E7%BB%9Crc%E9%81%A5%E6%8E%A7%E8%BD%A602-%E5%BC%80%E7%AF%87-%E5%B0%81%E9%9D%A2.jpg&quot; alt=&quot;WiFi/4G/5G 网络遥控车制作教程&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本教程介绍使用树莓派和遥控车制作一台可以通过网络控制的遥控车。软件使用我开发的 &lt;a href=&quot;https://github.com/itiwll/network-rc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;network-rc&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;材料&quot;&gt;&lt;a href=&quot;#材料&quot; class=&quot;headerlink&quot; title=&quot;材料&quot;&gt;&lt;/a&gt;材料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;树莓派 3B+ (300 元)&lt;/li&gt;
&lt;li&gt;树莓派摄像头 (15 元) / ps3 摄像头 (40 远)&lt;/li&gt;
&lt;li&gt;移动电源 (60 元) / USB 输出降压模块 (?元)&lt;/li&gt;
&lt;li&gt;环奇 743A (286 元，某宝上找不到了)&lt;/li&gt;
&lt;li&gt;杜邦线(公对公 x1, 公对母 x4) (3 元)&lt;/li&gt;
&lt;li&gt;其它固定材料&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="教程" scheme="https://blog.esonwong.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="网络遥控车" scheme="https://blog.esonwong.com/categories/%E6%95%99%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="技术" scheme="https://blog.esonwong.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络遥控车" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
      <category term="网络 RC" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C-RC/"/>
    
      <category term="WiFi/4G/5G 网络遥控车" scheme="https://blog.esonwong.com/tags/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6/"/>
    
      <category term="树莓派" scheme="https://blog.esonwong.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="网络图传" scheme="https://blog.esonwong.com/tags/%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%BC%A0/"/>
    
      <category term="树莓派小车" scheme="https://blog.esonwong.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%BD%A6/"/>
    
      <category term="WiFi/4G/5G 网络遥控车制作教程" scheme="https://blog.esonwong.com/tags/WiFi-4G-5G-%E7%BD%91%E7%BB%9C%E9%81%A5%E6%8E%A7%E8%BD%A6%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码的意义</title>
    <link href="https://blog.esonwong.com/HTTP-status/"/>
    <id>https://blog.esonwong.com/HTTP-status/</id>
    <published>2020-03-10T08:59:29.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/http-status-codes.jpg" alt="HTTP 状态码"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTTP 状态码是指 HTTP 响应报文里状态行里的 Status-Code，用于指示特定 HTTP 响应的状态和类型。</p><p>HTTP 响应报文状态行由 HTTP-Version、Status-Code、Reason-Phrase 组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><h2 id="响应状态码分为五类"><a href="#响应状态码分为五类" class="headerlink" title="响应状态码分为五类"></a>响应状态码分为五类</h2><h3 id="信息响应-100–199"><a href="#信息响应-100–199" class="headerlink" title="信息响应(100–199)"></a>信息响应(100–199)</h3><h4 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h4><p>如果客户端向服务器发送请求的 Header 里包含 <code>Expect: 100-continue</code>头，服务器应当响应 <code>100</code>,然后客户端再向服务器发送 body 数据。</p><h4 id="101-Switching-Protocol"><a href="#101-Switching-Protocol" class="headerlink" title="101 Switching Protocol"></a>101 Switching Protocol</h4><p>在如果客户端请求切换协议，切换协议之前，服务器响应 <code>101</code> 表示服务器也正在切换的协议。</p><p>比如客户端请求切换到 websocket 协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;ws HTTP&#x2F;1.1</span><br><span class="line">Host: xxx.com</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure><p>服务器响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure><p>接下来将以 websocket 协议进行通信。</p><h4 id="102-Processing-WebDAV"><a href="#102-Processing-WebDAV" class="headerlink" title="102 Processing (WebDAV)"></a>102 Processing (WebDAV)</h4><p>此代码表示服务器已收到并正在处理该请求，但没有响应可用。如果服务器需要很长时间处理一个请求，可以先响应此状态码，处理完再发送 body。</p><h4 id="103-Early-Hints"><a href="#103-Early-Hints" class="headerlink" title="103 Early Hints"></a>103 Early Hints</h4><p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Link" target="_blank" rel="noopener">Link</a>一起使用告知客户端需要预加载的一些文件，可加速网页加载。以 HTML 为列，通常浏览器需要加载 html 文件并解析到外部文件的引用才会开始加载这些文件，而利用此特性可以提前加载这些文件。</p><h3 id="成功响应-200–299"><a href="#成功响应-200–299" class="headerlink" title="成功响应(200–299)"></a>成功响应(200–299)</h3><p>成功响应状态的具体意义：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94" target="_blank" rel="noopener">成功响应</a></p><p>响应状态是 <code>202 Accepted</code> 的话，可能需要客户端继续轮询接口至响应状态为 <code>200 ok</code>。</p><h3 id="重定向-300–399"><a href="#重定向-300–399" class="headerlink" title="重定向(300–399)"></a>重定向(300–399)</h3><p>重定向响应状态的具体意义：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#重定向" target="_blank" rel="noopener">重定向响应</a></p><h3 id="客户端错误-400–499"><a href="#客户端错误-400–499" class="headerlink" title="客户端错误(400–499)"></a>客户端错误(400–499)</h3><p>4xx 错误是客户端发送的请求本身存在错误返回的状态，包括请求地址错误、请求参数错误、认证错误等。客户端不应该再重新发送请求，而是先解决错误。</p><p>客户端错误响应状态的具体意义：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#客户端响应" target="_blank" rel="noopener">客户端错误响应</a></p><h3 id="服务器错误-500–599"><a href="#服务器错误-500–599" class="headerlink" title="服务器错误 (500–599)"></a>服务器错误 (500–599)</h3><p>5xx 码告诉客户端其发送的请求是完美通过验证的但服务器端出现了一些问题。客户端可以无需做任务修改来继续向服务端发送请求。</p><p>服务器错误响应状态的具体意义：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#服务端响应" target="_blank" rel="noopener">服务器错误响应</a></p><h2 id="封装请求库处理异常状态"><a href="#封装请求库处理异常状态" class="headerlink" title="封装请求库处理异常状态"></a>封装请求库处理异常状态</h2><p>在开发时我们协商接口规范时，需要要求接口返回的状态码符合 <a href="https://tools.ietf.org/html/rfc2616#section-10" target="_blank" rel="noopener">section 10 of RFC 2616</a> 的定义 ，以便在客户端封装请求模块通过判断状态码统一处理请求异常。<br>比如： </p><ul><li>接口响应状态为 <code>401 Unauthorized</code> 时，客户端提示用户没有权限</li><li>接口响应状态为 5xx 时，弹出错误消息</li><li>接口响应状态为 <code>404 Not Found</code> 时， 提示“发出的请求针对的是不存在的记录，服务器没有进行操作” </li></ul><p>等等…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 响应代码</a></li><li><a href="https://tools.ietf.org/html/rfc2616#section-10" target="_blank" rel="noopener">section 10 of RFC 2616</a></li><li><a href="https://cloud.tencent.com/developer/article/1540087" target="_blank" rel="noopener">系统服务化构建-状态码设计要点</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../asset/http-status-codes.jpg&quot; alt=&quot;HTTP 状态码&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;HTTP 
      
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="http" scheme="https://blog.esonwong.com/tags/http/"/>
    
      <category term="开发规范" scheme="https://blog.esonwong.com/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的 Header 中的缓存相关字段介绍</title>
    <link href="https://blog.esonwong.com/HTTP-%E7%9A%84-Header-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%97%E6%AE%B5%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.esonwong.com/HTTP-%E7%9A%84-Header-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%97%E6%AE%B5%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-02-28T22:21:02.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/http-caching.png" alt="http 缓存"></p><h2 id="HTTP-Header-中的缓存相关字段"><a href="#HTTP-Header-中的缓存相关字段" class="headerlink" title="HTTP Header 中的缓存相关字段"></a>HTTP Header 中的缓存相关字段</h2><p>HTTP 请求和响应都包含 header 和 body 两个部分, 缓存相关的字段存在于 header 当中。HTTP 响应 header 中包含  <code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>，请求 header 中包含 <code>If-Modified-Since</code>、<code>If-None-Match</code>。</p><a id="more"></a><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 字段存在于 HTTP 响应头当中，仅在 HTTP 1.0 中生效。它的值是 资源过期的日期。现在的浏览器默认使用 HTTP 1.1, Expires 已经基本被淘汰。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code> 在 HTTP 请求和响应 Header 里。</p><p><code>Cache-Control</code> 可能的值为:</p><ul><li>max-age=&lt;seconds&gt;  设置缓存存储的最长时间</li><li>no-cache 不使用缓存的数据</li><li>no-store 不缓存数据</li><li>no-transform Header 里的某些字段不能由代理修改</li></ul><p>仅存在于请求 Header 的 <code>Cache-Control</code> 值:</p><ul><li>max-stale[=&lt;seconds&gt;]  设置共享缓存存储的最长时间</li><li>min-fresh=&lt;seconds&gt;  客户端希望获取一个能在指定的秒数内保持其最新状态的响应</li><li>only-if-cached 表明客户端只使用缓存，但是会请求验证资源是否还有效</li></ul><p>仅存在于响应 Header 中的 <code>Cache-Control</code> 值:</p><ul><li>must-revalidate  过期后不可用</li><li>public  可以被客户端或者代理服务器缓存</li><li>private  不能被代理服务器缓存</li><li>proxy-revalidate  共享缓存的资源过期后不可用</li><li>s-maxage=&lt;seconds&gt;  设置共享缓存存储的最长时间</li></ul><p><code>Cache-Control</code> 多个值之间用 <code>,</code> 隔开。</p><blockquote><p>共享缓存：代理服务器缓存</p></blockquote><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>存在于响应 Header 中，告诉客户端响应的资源最后的修改时间。</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>存在于请求 Header 中，告诉响应服务器请求的资源上次服务器返回的资源最后修改时间。<br>如果服务器上的资源又被修改过，则服务器应当返回新的资源，否者服务器返回 <code>304</code> HTTP 状态码告诉客户端使用缓存的资源.</p><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>存在于响应 Header 中, 值为的资源的唯一标识符。由服务器决定唯一标识符的生成方法，比如哈希值。</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>存在于请求 Header 中，告诉响应服务器请求的资源上次服务器返回的资源最后的 <code>Etag</code> 值。<br>如果服务器上的资源的唯一标识符与请求头中的 <code>Etag</code> 的值不一样，则服务器应当返回新的资源，否者服务器返回 <code>304</code> HTTP 状态码告诉客户端使用缓存的资源。唯一标识符 <code>Etag</code> 的规则优先于 <code>Last-Modified</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/http-caching.png&quot; alt=&quot;http 缓存&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;HTTP-Header-中的缓存相关字段&quot;&gt;&lt;a href=&quot;#HTTP-Header-中的缓存相关字段&quot; class=&quot;headerlink&quot; title=&quot;HTTP Header 中的缓存相关字段&quot;&gt;&lt;/a&gt;HTTP Header 中的缓存相关字段&lt;/h2&gt;&lt;p&gt;HTTP 请求和响应都包含 header 和 body 两个部分, 缓存相关的字段存在于 header 当中。HTTP 响应 header 中包含  &lt;code&gt;Expires&lt;/code&gt;、&lt;code&gt;Cache-Control&lt;/code&gt;、&lt;code&gt;Last-Modified&lt;/code&gt;、&lt;code&gt;Etag&lt;/code&gt;，请求 header 中包含 &lt;code&gt;If-Modified-Since&lt;/code&gt;、&lt;code&gt;If-None-Match&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="http缓存相关字段" scheme="https://blog.esonwong.com/tags/http%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%97%E6%AE%B5/"/>
    
      <category term="http header" scheme="https://blog.esonwong.com/tags/http-header/"/>
    
      <category term="缓存" scheme="https://blog.esonwong.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="缓存技术" scheme="https://blog.esonwong.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
      <category term="性能优化" scheme="https://blog.esonwong.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>怎么养才能坚持做一件事情</title>
    <link href="https://blog.esonwong.com/%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%9D%9A%E6%8C%81%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85/"/>
    <id>https://blog.esonwong.com/%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%9D%9A%E6%8C%81%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85/</id>
    <published>2020-02-23T08:50:16.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../asset/%E5%9D%9A%E6%8C%81.jpg" alt="坚持"> </p><h2 id="我们很难坚持一件事情"><a href="#我们很难坚持一件事情" class="headerlink" title="我们很难坚持一件事情"></a>我们很难坚持一件事情</h2><p>我们总会高估自己短时间能达成目标，造成挫败感；且低估长时间可以达成的成就，失去信心。因此我们要正确的认识自己的能力，并用一些切实可行的方法来帮助我们坚持下去。</p><a id="more"></a><h2 id="切碎你的目标，保持及时的反馈"><a href="#切碎你的目标，保持及时的反馈" class="headerlink" title="切碎你的目标，保持及时的反馈"></a>切碎你的目标，保持及时的反馈</h2><p>当你定制一个大目标时，往往这个目标相对于现在的你是有相当有难度的，不容易完成。如果目标拆分成许多的小目标，每完成一个小目标给自己一个反馈，那么就更有可能持续投入完成这个目标。</p><p>我们会遇到到许多为了让你持续投入下去而设计的持续反馈的机制。比如，游戏角色等级提升时腾出的光柱，某些 App 中的签到功能，英语等级考试。我们也可以利用这样的机制达成我们自己的目标。</p><p>在拆分目标要注意，切碎的目标技能挑战比要刚刚好。切碎到有一点挑战，但是在短时间之内可以完成，如果时间太长，你就失去了不间断的反馈。</p><h2 id="不确定性反馈"><a href="#不确定性反馈" class="headerlink" title="不确定性反馈"></a>不确定性反馈</h2><p>不确定性反馈充满魅力。如果做一件事情有着不确定的结果，例如玩游戏会随机掉落装备，抓娃娃机可能会成功或失败，赌博有机会让你赢钱或暴富，工作中有升迁机会，那么有的人会不断的投入到这些事情当中。</p><p>在行为经济区学的<a href="https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%BC%B7" target="_blank" rel="noopener">强化</a>理论中，可以把这类事情认为是变动比率强化。变化比率强化产生较高的反应频率，且对消弱有较大的抵抗力。即做一件事情每一次有着不同程度的积极反馈，会促使你更高频率做这件事情，且不容易放弃。</p><p>所以在每次完成小目标的时候给自己一个奖励，准备一个以上的奖励方案。用硬币或者一个随机程序🎲决定得到哪个奖励，可以让你更容易坚持下去。</p><!-- 变动时距强化，在奖励选项中加入“无”的选项。 --><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=1YI1k1iTFd8&list=PLgKcFbbQ9Io4YqBIIh-U0ujdO9f8jHKfN&index=2&t=735s" target="_blank" rel="noopener">罗振宇 知识就是力量：怎样逼自己成为一个上进的人</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%BC%B7" target="_blank" rel="noopener">强化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../asset/%E5%9D%9A%E6%8C%81.jpg&quot; alt=&quot;坚持&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;我们很难坚持一件事情&quot;&gt;&lt;a href=&quot;#我们很难坚持一件事情&quot; class=&quot;headerlink&quot; title=&quot;我们很难坚持一件事情&quot;&gt;&lt;/a&gt;我们很难坚持一件事情&lt;/h2&gt;&lt;p&gt;我们总会高估自己短时间能达成目标，造成挫败感；且低估长时间可以达成的成就，失去信心。因此我们要正确的认识自己的能力，并用一些切实可行的方法来帮助我们坚持下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自我提升" scheme="https://blog.esonwong.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="自我提升" scheme="https://blog.esonwong.com/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>webpack 前端项目的最小更新的配置方法</title>
    <link href="https://blog.esonwong.com/webpack-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.esonwong.com/webpack-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</id>
    <published>2020-02-18T08:40:29.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt="webpak"></p><p>本文将介绍使用 webpack 打包的 web 应用如何在更新时只需下载有变动的模块。</p><a id="more"></a><h2 id="webpack-的默认输出"><a href="#webpack-的默认输出" class="headerlink" title="webpack 的默认输出"></a>webpack 的默认输出</h2><p>webpack 用于编译 javascript 模块。默认为 <code>entry</code> 配置中指定的每一个入口文件，输出每个入口文件引用的所有模块打包的 js 文件，共同引用的模块将被打包到每个入口的打包文件。</p><blockquote><p>本文的 webpack 特指 webpakc v4。</p></blockquote><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>wepack 提供了 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a> 分离代码，在 webpack 配置中加入 <code>optimization.splitChunks</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// include all types of chunks</span></span><br><span class="line">      chunks: <span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用的模块将被抽出单独打包成js文件。</p><p>如果我们使用 <code>import()</code> 懒加载模块，此模块也将被单独打包js文件。</p><h2 id="输出-content-hash-文件名"><a href="#输出-content-hash-文件名" class="headerlink" title="输出 content hash 文件名"></a>输出 content hash 文件名</h2><p>为了达到最小更新的的目的，关键就是缓存没有更新的模块。</p><p>为了缓存模块，需要让输出文件的文件名在内容不变的情况下不发生改变。在 webpack 的 output 配置中使用 <code>contenthash</code> 占位符指定输出文件名，根据内容计算文件名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    filename: <span class="string">"[name].[contenthash].js"</span>,</span><br><span class="line">    chunkFilename: <span class="string">"[name].[contenthash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx-缓存配置"><a href="#Nginx-缓存配置" class="headerlink" title="Nginx 缓存配置"></a>Nginx 缓存配置</h2><p>以 nginx 为例配置资源缓存。</p><p>对 index.html 进行无缓存配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F;index.html &#123;</span><br><span class="line">add_header Cache-Control &quot;no-cache, no-store&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它资源文件设置一个较长时间的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">&#123;</span><br><span class="line">expires  1y;</span><br><span class="line">&#125;</span><br><span class="line">location ~ .*\.(js|css)?$</span><br><span class="line">&#123;</span><br><span class="line">expires  1y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小化前端项目更新的工作完成。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>发布的时，服务器上有相同的路径和文件名的文件可以不传输，实现增量发布。</li><li>用户在回访网站的时候，未更新的模块将保持缓存，实现缓存效益最大化，大大增加加载速度。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>用户在首次访问加载时会略微增加下载数据量。</li><li><code>contenthash</code>不能在启用 HMR 时使用。</li><li>一个模块更新时会导致整个引用链的更新，包含这个模块应用链的输出文件都需要更新。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://webpack.docschina.org/guides/code-splitting/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">代码分离</a></li><li><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a></li><li><a href="怎么用-webpack-实现-js-模块按需懒加载.md">怎么用-webpack-实现-js-模块按需懒加载</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;webpak&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍使用 webpack 打包的 web 应用如何在更新时只需下载有变动的模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://blog.esonwong.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="javascript" scheme="https://blog.esonwong.com/tags/javascript/"/>
    
      <category term="webpack" scheme="https://blog.esonwong.com/tags/webpack/"/>
    
      <category term="webpack 配置" scheme="https://blog.esonwong.com/tags/webpack-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="最小更新" scheme="https://blog.esonwong.com/tags/%E6%9C%80%E5%B0%8F%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>fetch 上传进度的替代发方案</title>
    <link href="https://blog.esonwong.com/fetch-%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%8F%91%E6%96%B9%E6%A1%88/"/>
    <id>https://blog.esonwong.com/fetch-%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%8F%91%E6%96%B9%E6%A1%88/</id>
    <published>2020-02-16T08:39:54.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fetch-无法获取上传文件的进度"><a href="#fetch-无法获取上传文件的进度" class="headerlink" title="fetch 无法获取上传文件的进度"></a>fetch 无法获取上传文件的进度</h2><p>目前 fetch 没有类似 <code>XMLHttpRequest</code> 实例的 <code>upload.onprogress</code>, 所以需要现实上传进度的话需要使用 <code>XMLHttpRequest</code> 来上传文件。<br><a href="https://github.com/github/fetch/issues/89" target="_blank" rel="noopener">相关讨论</a></p><a id="more"></a><h2 id="使用-XMLHttpRequest-替代"><a href="#使用-XMLHttpRequest-替代" class="headerlink" title="使用 XMLHttpRequest 替代"></a>使用 XMLHttpRequest 替代</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = (<span class="keyword">this</span>.xhr = <span class="keyword">new</span> XMLHttpRequest());</span><br><span class="line">  xhr.open(<span class="string">"put"</span>, uploadUrl);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">"auth"</span>, <span class="string">"xxx"</span>);</span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"上传进度"</span>, event.loaded / event.total);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">"上传失败！"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.onabort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">"已取消上传"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.upload.onabort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">"已取消上传"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(file);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/github/fetch/issues/89" target="_blank" rel="noopener">github/fetch/issuse/upload progress?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;fetch-无法获取上传文件的进度&quot;&gt;&lt;a href=&quot;#fetch-无法获取上传文件的进度&quot; class=&quot;headerlink&quot; title=&quot;fetch 无法获取上传文件的进度&quot;&gt;&lt;/a&gt;fetch 无法获取上传文件的进度&lt;/h2&gt;&lt;p&gt;目前 fetch 没有类似 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 实例的 &lt;code&gt;upload.onprogress&lt;/code&gt;, 所以需要现实上传进度的话需要使用 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 来上传文件。&lt;br&gt;&lt;a href=&quot;https://github.com/github/fetch/issues/89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关讨论&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="javascript" scheme="https://blog.esonwong.com/tags/javascript/"/>
    
      <category term="fetch" scheme="https://blog.esonwong.com/tags/fetch/"/>
    
      <category term="上传文件" scheme="https://blog.esonwong.com/tags/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    
      <category term="XMLHttpRequest" scheme="https://blog.esonwong.com/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>如何终止 fetch 请求</title>
    <link href="https://blog.esonwong.com/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2-fetch-%E8%AF%B7%E6%B1%82/"/>
    <id>https://blog.esonwong.com/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2-fetch-%E8%AF%B7%E6%B1%82/</id>
    <published>2020-02-14T09:30:00.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fetch-介绍"><a href="#fetch-介绍" class="headerlink" title="fetch 介绍"></a>fetch 介绍</h2><p>fetch 以返回 <code>Promise</code> 方式替代 <code>XMLHttpRequest</code> 实现的异步请求。可以使代码书写显得更简介。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> fetch(url).then(<span class="function"><span class="params">respones</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> response.json();</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>我们通常要使用 <a href="https://github.com/github/fetch" target="_blank" rel="noopener">fetch polyfill</a> ，以确保可以在使用 fetch 时可以兼容常用浏览器。</p><h2 id="AbortController-介绍"><a href="#AbortController-介绍" class="headerlink" title="AbortController 介绍"></a><code>AbortController</code> 介绍</h2><p>如果我们需要手动终止 fetch 发出的请求。则需要使用 <code>AbortController</code>。</p><a id="more"></a><p><code>AbortController</code> 实例化对象提供一个 <code>signal</code> 标记属性，把该 <code>signal</code> 作为参数传入 fetch 方法，则可以调用该实例化对象的 <code>abort</code> 方法来终止 fetch 请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"><span class="keyword">let</span> signal = controller.signal;</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  signal: signal</span><br><span class="line"> &#125;);</span><br><span class="line"> controller.abort();</span><br></pre></td></tr></table></figure><p>使用 <a href="https://github.com/github/fetch" target="_blank" rel="noopener">fetch polyfill</a> 时如何使用 <code>AbortController</code> ：<a href="https://github.com/github/fetch#aborting-requests" target="_blank" rel="noopener">aborting requests</a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">使用 Fetch</a></li><li><a href="https://github.com/github/fetch" target="_blank" rel="noopener">fetch polyfill</a></li><li><a href="https://github.com/github/fetch#aborting-requests" target="_blank" rel="noopener">aborting requests</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;fetch-介绍&quot;&gt;&lt;a href=&quot;#fetch-介绍&quot; class=&quot;headerlink&quot; title=&quot;fetch 介绍&quot;&gt;&lt;/a&gt;fetch 介绍&lt;/h2&gt;&lt;p&gt;fetch 以返回 &lt;code&gt;Promise&lt;/code&gt; 方式替代 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 实现的异步请求。可以使代码书写显得更简介。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; data = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch(url).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;respones&lt;/span&gt; =&amp;gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们通常要使用 &lt;a href=&quot;https://github.com/github/fetch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fetch polyfill&lt;/a&gt; ，以确保可以在使用 fetch 时可以兼容常用浏览器。&lt;/p&gt;
&lt;h2 id=&quot;AbortController-介绍&quot;&gt;&lt;a href=&quot;#AbortController-介绍&quot; class=&quot;headerlink&quot; title=&quot;AbortController 介绍&quot;&gt;&lt;/a&gt;&lt;code&gt;AbortController&lt;/code&gt; 介绍&lt;/h2&gt;&lt;p&gt;如果我们需要手动终止 fetch 发出的请求。则需要使用 &lt;code&gt;AbortController&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="javascript" scheme="https://blog.esonwong.com/tags/javascript/"/>
    
      <category term="fetch" scheme="https://blog.esonwong.com/tags/fetch/"/>
    
      <category term="终止 fetch" scheme="https://blog.esonwong.com/tags/%E7%BB%88%E6%AD%A2-fetch/"/>
    
      <category term="AbortController" scheme="https://blog.esonwong.com/tags/AbortController/"/>
    
  </entry>
  
  <entry>
    <title>使用 Github Actions 部署前端项目到</title>
    <link href="https://blog.esonwong.com/%E4%BD%BF%E7%94%A8-Github-Actions-%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    <id>https://blog.esonwong.com/%E4%BD%BF%E7%94%A8-Github-Actions-%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-02-08T09:37:28.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Github-Actions-简介"><a href="#Github-Actions-简介" class="headerlink" title="Github Actions 简介"></a>Github Actions 简介</h2><p>GitHub Actions 是 Github 推出的一项服务。提供了虚拟服务器环境和 <a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">Actions 市场</a>，用于 github 上的项目进行持续集成。这对于 Github 上公开的仓库是免费的，私有仓库有服务器运行时间和存储空间的限制，具体请看 <a href="https://help.github.com/en/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions#about-billing-for-github-actions" target="_blank" rel="noopener">about billing for github actions</a>。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>下面介绍怎么如使用 GitHub Actions 部署一个前端项目到 linux 服务器上。</p><a id="more"></a><h3 id="建立-workflow-配置文件"><a href="#建立-workflow-配置文件" class="headerlink" title="建立 workflow 配置文件"></a>建立 <code>workflow</code> 配置文件</h3><p>在仓库的根目录中创建文件夹 <code>.github/workflows</code>。在此文件夹中创建一个 <code>.yml</code> 后缀的文件。 </p><p>文件内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br></pre></td></tr></table></figure><h3 id="指定触发事件"><a href="#指定触发事件" class="headerlink" title="指定触发事件"></a>指定触发事件</h3><p>我们以推送到 master 分支为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>更多触发方式参考 <a href="https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow#triggering-a-workflow-with-events" target="_blank" rel="noopener">Triggering a workflow with events</a> 和 <a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener">Workflow syntax for GitHub Actions</a>。</p><h3 id="配置-jobs-和-build"><a href="#配置-jobs-和-build" class="headerlink" title="配置 jobs 和 build"></a>配置 jobs 和 build</h3><p>事件可以触发的多个 job，这里我们添加一个 build job, 指定运行环境。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">[12.x]</span></span><br></pre></td></tr></table></figure><h3 id="配置-steps"><a href="#配置-steps" class="headerlink" title="配置 steps"></a>配置 steps</h3><p>在 build 下配置 steps。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br></pre></td></tr></table></figure><h4 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h4><p>使用 <a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">Actions 市场</a> 里的 <a href="https://github.com/actions/checkout" target="_blank" rel="noopener">actions/checkout</a> 获取仓库代码，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br></pre></td></tr></table></figure><h4 id="安装模块和构建"><a href="#安装模块和构建" class="headerlink" title="安装模块和构建"></a>安装模块和构建</h4><p>使用 npm 安装模块和运行 build script。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>我们要使用 <code>rsync</code> 命令来同步构建好的文件目录到到发布目标服务器。</p><p>首先要准备可以在目标服务器上发布的私钥和 known-hosts，添加到仓库设置的 Secrets 中，命名为 <code>SSH_PRIVATE_KEY</code> 和 <code>KNOWN_HOSTS_TEST</code> 这样可以避免被暴露而在配置中使用。用 <a href="https://github.com/shimataro/ssh-key-action" target="_blank" rel="noopener">shimataro/ssh-key-action</a> 安装私钥到 Github Action 的虚拟服务器。</p><p><img src="../asset/add-secret.png" alt="添加服务器发布私钥"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">SSH</span> <span class="string">key</span> <span class="string">for</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">shimataro/ssh-key-action@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">id_rsa-deploy</span></span><br><span class="line">    <span class="attr">private-key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">known-hosts:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KNOWN_HOSTS_TEST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">config:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">Host</span> <span class="string">deploy</span></span><br><span class="line">        <span class="string">HostName</span> <span class="string">xxx.xxx.xxx</span></span><br><span class="line">        <span class="string">User</span> <span class="string">user-of-deploy</span></span><br><span class="line">        <span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa-deploy</span></span><br></pre></td></tr></table></figure><p>使用 <code>rsync</code> 命令同步发布文件夹。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">rsync</span> <span class="string">-rv</span> <span class="string">$GITHUB_WORKSPACE/dist/</span> <span class="string">user@xxx.xxx.xxx:/www/demo</span></span><br></pre></td></tr></table></figure><h3 id="推送代码"><a href="#推送代码" class="headerlink" title="推送代码"></a>推送代码</h3><p>接下来推送代码到 master 分支即可执行这个 workflow ，将项目部署到服务器。可以在仓库的 Actions 菜单查看运行日志。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>链接：<a href="https://github.com/itiwll/github-actions-deploy-front-end-example" target="_blank" rel="noopener">Github Actions 发布前端项目演示</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions" target="_blank" rel="noopener">GitHub Actions Documentation</a></li><li><a href="https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow#triggering-a-workflow-with-events" target="_blank" rel="noopener">Triggering a workflow with events</a></li><li><a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">actions 市场</a></li><li><a href="https://help.github.com/en/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions#about-billing-for-github-actions" target="_blank" rel="noopener">about billing for github actions</a></li><li><a href="https://github.com/itiwll/github-actions-deploy-front-end-example" target="_blank" rel="noopener">Github Actions 发布前端项目演示</a></li><li><a href="https://github.com/actions/checkout" target="_blank" rel="noopener">actions/checkout</a></li><li><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener">Workflow syntax for GitHub Actions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Github-Actions-简介&quot;&gt;&lt;a href=&quot;#Github-Actions-简介&quot; class=&quot;headerlink&quot; title=&quot;Github Actions 简介&quot;&gt;&lt;/a&gt;Github Actions 简介&lt;/h2&gt;&lt;p&gt;GitHub Actions 是 Github 推出的一项服务。提供了虚拟服务器环境和 &lt;a href=&quot;https://github.com/marketplace?type=actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actions 市场&lt;/a&gt;，用于 github 上的项目进行持续集成。这对于 Github 上公开的仓库是免费的，私有仓库有服务器运行时间和存储空间的限制，具体请看 &lt;a href=&quot;https://help.github.com/en/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions#about-billing-for-github-actions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;about billing for github actions&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h2&gt;&lt;p&gt;下面介绍怎么如使用 GitHub Actions 部署一个前端项目到 linux 服务器上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://blog.esonwong.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="github actions" scheme="https://blog.esonwong.com/tags/github-actions/"/>
    
      <category term="自动部署" scheme="https://blog.esonwong.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
      <category term="前端部署" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
      <category term="自动化" scheme="https://blog.esonwong.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Ecmascript 提案：空值合并运算符 &quot;??&quot; </title>
    <link href="https://blog.esonwong.com/Ecmascript-%E6%8F%90%E6%A1%88-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://blog.esonwong.com/Ecmascript-%E6%8F%90%E6%A1%88-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-02-05T20:37:15.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果控制合并运算符 <code>??</code> 左边的值为 <code>null</code> 或 <code>undefined</code> ，表达式会返回控制合并运算符右边的值，否则返回左边的值。</p><p>已经进入 stage 4(Finished) 阶段，等待加入标准。</p><a id="more"></a><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    name: <span class="string">"eson"</span>,</span><br><span class="line">    age: <span class="number">0</span>,</span><br><span class="line">    address: <span class="literal">null</span>,</span><br><span class="line">    gender: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userName = user.name ?? <span class="string">"unknown"</span>; <span class="comment">// "eson"</span></span><br><span class="line"><span class="keyword">const</span> userAge = user.age ?? <span class="number">18</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> userAddress = user.address ?? <span class="string">"unknown"</span>; <span class="comment">// "unknown"</span></span><br><span class="line"><span class="keyword">const</span> userGender = user.gender ?? <span class="string">"male"</span>; <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><h2 id="作用和使用场景"><a href="#作用和使用场景" class="headerlink" title="作用和使用场景"></a>作用和使用场景</h2><p><code>??</code> 主要可以用来获取对象属性值时替代 <code>||</code> 来设定默认值。使用 <code>||</code> 时，如果 <code>||</code> 左边的值为 <code>0</code> 或者空字符串，表达仍然降返回右边的值.</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userAge = user.age || <span class="number">18</span>; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">const</span> userAddress = user.address || <span class="string">"unknown"</span>; <span class="comment">// "unknown"</span></span><br><span class="line"><span class="keyword">const</span> userGender = user.gender || <span class="string">"male"</span>; <span class="comment">// "male"</span></span><br></pre></td></tr></table></figure><h2 id="使用-bable-插件支持空值合并运算符"><a href="#使用-bable-插件支持空值合并运算符" class="headerlink" title="使用 bable 插件支持空值合并运算符"></a>使用 bable 插件支持空值合并运算符</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-proposal-nullish-coalescing-operator</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn add @babel/plugin-proposal-nullish-coalescing-operator -D</span><br></pre></td></tr></table></figure><h3 id="babel-配置"><a href="#babel-配置" class="headerlink" title="babel 配置"></a>babel 配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-proposal-nullish-coalescing-operator"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/tc39/proposal-nullish-coalescing" target="_blank" rel="noopener">tc3/proposal-nullish-coalescing</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" target="_blank" rel="noopener">@babel/plugin-proposal-nullish-coalescing-operator</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如果控制合并运算符 &lt;code&gt;??&lt;/code&gt; 左边的值为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，表达式会返回控制合并运算符右边的值，否则返回左边的值。&lt;/p&gt;
&lt;p&gt;已经进入 stage 4(Finished) 阶段，等待加入标准。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="babel" scheme="https://blog.esonwong.com/tags/babel/"/>
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="前端" scheme="https://blog.esonwong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="技术" scheme="https://blog.esonwong.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="空值合并运算符" scheme="https://blog.esonwong.com/tags/%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="nullish coalescing" scheme="https://blog.esonwong.com/tags/nullish-coalescing/"/>
    
      <category term="??" scheme="https://blog.esonwong.com/tags//"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ecmascript 提案：可选链 &quot;?.&quot; </title>
    <link href="https://blog.esonwong.com/Ecmascript-%E6%8F%90%E6%A1%88%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    <id>https://blog.esonwong.com/Ecmascript-%E6%8F%90%E6%A1%88%E5%8F%AF%E9%80%89%E9%93%BE/</id>
    <published>2020-01-31T20:37:15.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可选链提案"><a href="#可选链提案" class="headerlink" title="可选链提案"></a>可选链提案</h2><p>可选链 Optional Chaining 是一项方便读取对象属性值的 ECMAScript 语法提案。它将检测将要读取属性所属的对象是否为 <code>null</code> 或者 <code>undefined</code>，如果是将会返回 <code>undefinde</code>, 另外也可调用方法时用作于检测方法是否存在，如果存在则执行。已经进入 stage 4(Finished) 阶段，等待加入标准。</p><a id="more"></a><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">"eson"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> name = user?.name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> item0 = list?.[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">func.?();</span><br></pre></td></tr></table></figure><h2 id="作用和使用场景"><a href="#作用和使用场景" class="headerlink" title="作用和使用场景"></a>作用和使用场景</h2><p>许多 API 或者后端接口返回的结果通常是一个 <code>object</code> 或者 <code>array</code>, 如果没有可用值则会返回 <code>null</code> 或 <code>undefined</code>， 通常只有结果不为 <code>null</code> 或 <code>undefined</code> 的时候我们才会去读取它的属性。<code>?.</code> 可以省去烦人的对象检测。</p><h2 id="使用-bable-插件支持可选链语法"><a href="#使用-bable-插件支持可选链语法" class="headerlink" title="使用 bable 插件支持可选链语法"></a>使用 bable 插件支持可选链语法</h2><p>现在通过 babel 的 proposal-optional-chaining 插件可以提前享用可选链语法。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-proposal-optional-chaining</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn add @babel/plugin-proposal-optional-chaining -D</span><br></pre></td></tr></table></figure><h3 id="babel-配置"><a href="#babel-配置" class="headerlink" title="babel 配置"></a>babel 配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-proposal-optional-chaining"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://github.com/tc39/proposal-optional-chaining" target="_blank" rel="noopener">tc39 / proposal-optional-chaining</a></p></li><li><p><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" target="_blank" rel="noopener">@babel/plugin-proposal-optional-chaining</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可选链提案&quot;&gt;&lt;a href=&quot;#可选链提案&quot; class=&quot;headerlink&quot; title=&quot;可选链提案&quot;&gt;&lt;/a&gt;可选链提案&lt;/h2&gt;&lt;p&gt;可选链 Optional Chaining 是一项方便读取对象属性值的 ECMAScript 语法提案。它将检测将要读取属性所属的对象是否为 &lt;code&gt;null&lt;/code&gt; 或者 &lt;code&gt;undefined&lt;/code&gt;，如果是将会返回 &lt;code&gt;undefinde&lt;/code&gt;, 另外也可调用方法时用作于检测方法是否存在，如果存在则执行。已经进入 stage 4(Finished) 阶段，等待加入标准。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="babel" scheme="https://blog.esonwong.com/tags/babel/"/>
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="可选链" scheme="https://blog.esonwong.com/tags/%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    
      <category term="optional chaining" scheme="https://blog.esonwong.com/tags/optional-chaining/"/>
    
      <category term="?." scheme="https://blog.esonwong.com/tags//"/>
    
  </entry>
  
  <entry>
    <title>怎么用 webpack 实现 js 模块按需懒加载？</title>
    <link href="https://blog.esonwong.com/%E6%80%8E%E4%B9%88%E7%94%A8-webpack-%E5%AE%9E%E7%8E%B0-js-%E6%A8%A1%E5%9D%97%E6%8C%89%E9%9C%80%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://blog.esonwong.com/%E6%80%8E%E4%B9%88%E7%94%A8-webpack-%E5%AE%9E%E7%8E%B0-js-%E6%A8%A1%E5%9D%97%E6%8C%89%E9%9C%80%E6%87%92%E5%8A%A0%E8%BD%BD/</id>
    <published>2020-01-28T11:28:49.000Z</published>
    <updated>2021-03-27T15:48:26.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态导入，ECMAScript-import-提案"><a href="#动态导入，ECMAScript-import-提案" class="headerlink" title="动态导入，ECMAScript import() 提案"></a>动态导入，ECMAScript <code>import()</code> 提案</h2><p>ECMAScript 有一项允许使用 <code>import()</code> 方法传入 url 返回 <code>Promise</code> 动态导入 ES 模块的提案。已经进入 stage 4(Finished) 阶段，等待加入标准。</p><a id="more"></a><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js"</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">rep</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vue'</span>,rep.default)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Webpack 提供了 <code>import()</code> 语法，但是 Webpack 并不支持网络模块的导入。 Webpack 可以以本地路径或项目中安装的模块名动态导入模块。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./a.js"</span>) <span class="comment">// 本地路径</span></span><br><span class="line">  .then(<span class="function"><span class="params">rep</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vue'</span>,rep.default)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"vue"</span>) <span class="comment">// 安装的模块名</span></span><br><span class="line">  .then(<span class="function"><span class="params">rep</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>,rep.default)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><em>注： 使用 Webpack 的 <code>import()</code> 传递动态的本地 path 需要一些技巧</em></p><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p>Vue Router 配置的 component 属性支持传递一个返回 <code>Promise</code> 的方法，在匹配到路由准备渲染组件前会掉用此方法加载组件。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="组件加载状态"><a href="#组件加载状态" class="headerlink" title="组件加载状态"></a>组件加载状态</h2><p>Vue 函数式组件的 <code>createElemnt</code> （即 <code>h</code>）方法的第一个参数支持传递一个指定异步渲染的组件、加载时渲染的组件和加载失败渲染的组件的对象。我们可以据此创建一个懒加载容器组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">lazyLoadView</span>(<span class="params">AsyncView</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AsyncHandler = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">    component: AsyncView,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">    loading: Loading,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">    <span class="comment">// error: Error,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">    delay: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">    <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">    timeout: <span class="number">10000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    render(h, &#123; data, children &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(AsyncHandler, data, children);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改路由配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">"/foo"</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        lazyLoadView(</span><br><span class="line">         <span class="keyword">import</span>(<span class="string">"./Foo.vue"</span>)</span><br><span class="line">          <span class="comment">// 模拟网络延迟</span></span><br><span class="line">          <span class="comment">// new Promise(resolve =&gt; &#123;</span></span><br><span class="line">          <span class="comment">//   window.setTimeout(rep =&gt; &#123;</span></span><br><span class="line">          <span class="comment">//     resolve(import("./Foo.vue"));</span></span><br><span class="line">          <span class="comment">//   &#125;, 5000);</span></span><br><span class="line">          <span class="comment">// &#125;)</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><iframe     src="https://codesandbox.io/embed/vue-router-import-plws9?fontsize=14&hidenavigation=1&theme=dark"     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"     title="vue-router-import"     allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"     sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"   ></iframe><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">tc39/proposal-dynamic-import</a></li><li><a href="https://tc39.es/process-document/" target="_blank" rel="noopener">The TC39 Process</a></li><li><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">Vue Router - 路由懒加载</a></li><li><a href="https://juejin.im/post/5b90d0fcf265da0aa81bd728" target="_blank" rel="noopener">Vue异步组件处理路由组件加载状态</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态导入，ECMAScript-import-提案&quot;&gt;&lt;a href=&quot;#动态导入，ECMAScript-import-提案&quot; class=&quot;headerlink&quot; title=&quot;动态导入，ECMAScript import() 提案&quot;&gt;&lt;/a&gt;动态导入，ECMAScript &lt;code&gt;import()&lt;/code&gt; 提案&lt;/h2&gt;&lt;p&gt;ECMAScript 有一项允许使用 &lt;code&gt;import()&lt;/code&gt; 方法传入 url 返回 &lt;code&gt;Promise&lt;/code&gt; 动态导入 ES 模块的提案。已经进入 stage 4(Finished) 阶段，等待加入标准。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.esonwong.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript" scheme="https://blog.esonwong.com/tags/ECMAScript/"/>
    
      <category term="web 开发" scheme="https://blog.esonwong.com/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="webpack" scheme="https://blog.esonwong.com/tags/webpack/"/>
    
      <category term="懒加载" scheme="https://blog.esonwong.com/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="import" scheme="https://blog.esonwong.com/tags/import/"/>
    
      <category term="vue" scheme="https://blog.esonwong.com/tags/vue/"/>
    
  </entry>
  
</feed>
